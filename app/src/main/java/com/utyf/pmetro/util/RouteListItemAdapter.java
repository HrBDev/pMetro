package com.utyf.pmetro.util;import android.content.Context;import android.graphics.Canvas;import android.graphics.ColorFilter;import android.graphics.Paint;import android.graphics.PixelFormat;import android.graphics.drawable.Drawable;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.ArrayAdapter;import android.widget.ImageView;import android.widget.LinearLayout;import android.widget.TextView;import com.utyf.pmetro.R;import com.utyf.pmetro.map.Line;import com.utyf.pmetro.map.MAP_Parameters;import com.utyf.pmetro.map.MapData;import com.utyf.pmetro.map.routing.RouteInfo;import java.util.ArrayList;/** * Created by Fedor on 10.04.2016. * * Adapter for displaying a route in the list of alternative routes */public class RouteListItemAdapter extends ArrayAdapter<RouteInfo> {    private int resource;    private Context context;    private MapData mapData; // Required to get line colors    private enum ConnectionType {        TRANSFER,        TRAIN    }    private class RouteDrawInfo {        int[] stationColors;        ConnectionType[] connectionTypes;    }    public RouteListItemAdapter(Context context, int resource, RouteInfo[] objects, MapData mapData) {        super(context, resource, objects);        this.context = context;        this.resource = resource;        this.mapData = mapData;    }    @Override    public View getView(int position, View convertView, ViewGroup parent) {        RouteInfo route = getItem(position);        LinearLayout view;        if (convertView == null) {            LayoutInflater inflater = LayoutInflater.from(context);            view = (LinearLayout)inflater.inflate(resource, null);        }        else {            view = (LinearLayout)convertView;            // Remove all children except TextView            view.removeViewsInLayout(1, view.getChildCount() - 1);        }        TextView textView = (TextView)view.findViewById(R.id.textView3);        int minutes = Math.round(route.getTime());        String time;        if (minutes <= 60) {            time = String.format("%d", minutes);        } else {            int hours = minutes / 60;            minutes %= 60;            time = String.format("%d:%02d", hours, minutes);        }        String text = String.format("%s", time);        textView.setText(text);        RouteDrawInfo drawInfo = getRouteColors(route);        LayoutInflater inflater = LayoutInflater.from(context);        ImageView imageView = (ImageView)inflater.inflate(R.layout.metro_line_icon, view, false);        imageView.setImageDrawable(new RouteImage(drawInfo, mapData.map.parameters));        view.addView(imageView);        return view;    }    private void addRouteColor(StationsNum node, ArrayList<Integer> colorsList) {        Line line = mapData.map.getLine(node.trp, node.line);        if (line == null)            line = mapData.mapMetro.getLine(node.trp, node.line);        if (line != null)            colorsList.add(line.parameters.Color);        else            colorsList.add(0xff000000); // Cannot get color from the loaded map    }    // Returns list of colors of lines as they are traversed in the route    private RouteDrawInfo getRouteColors(RouteInfo routes) {        // Find continuous sequences of nodes having the same color and save their colors to colorsList        ArrayList<Integer> colorsList = new ArrayList<>();        ArrayList<ConnectionType> connectionsList = new ArrayList<>();        StationsNum prevNode = null;        boolean isTrainConnectionAdded = false;        for (StationsNum node: routes.getStations()) {            // Check if current line differs from previous one            if (prevNode != null && (prevNode.line != node.line || prevNode.trp != node.trp)) {                addRouteColor(prevNode, colorsList);                connectionsList.add(ConnectionType.TRANSFER);                isTrainConnectionAdded = false;            }            else if (prevNode != null && !isTrainConnectionAdded) {                addRouteColor(prevNode, colorsList);                connectionsList.add(ConnectionType.TRAIN);                isTrainConnectionAdded = true;            }            prevNode = node;        }        if (prevNode != null) {            addRouteColor(prevNode, colorsList);            // Connection is not added            // connectionsList.size() == colorsList.size() - 1        }        // Convert ArrayList to array        int[] colors = new int[colorsList.size()];        for (int i = 0; i < colors.length; i++) {            colors[i] = colorsList.get(i);        }        // Convert ArrayList to array        ConnectionType[] connections = connectionsList.toArray(new ConnectionType[connectionsList.size()]);        // Return result        RouteDrawInfo drawInfo = new RouteDrawInfo();        drawInfo.stationColors = colors;        drawInfo.connectionTypes = connections;        return drawInfo;    }    class RouteImage extends Drawable {        private final Paint mFillPaint;        private final Paint mLinePaint;        private final RouteDrawInfo mDrawInfo;        private final float mLineWidth;        private final float mStationRadius;        private float[] mCoords;        private float mHeight;        public RouteImage(RouteDrawInfo drawInfo, MAP_Parameters mapParameters) {            mFillPaint = new Paint(Paint.ANTI_ALIAS_FLAG);            mFillPaint.setStyle(Paint.Style.FILL);            mLinePaint = new Paint(mFillPaint);            mLinePaint.setStyle(Paint.Style.STROKE);            mDrawInfo = drawInfo;            mLineWidth = mapParameters.LinesWidth;            mStationRadius = mapParameters.StationRadius;            mCoords = new float[drawInfo.stationColors.length];            mCoords[0] = 0;            float transferLength = mStationRadius * 3f;            float trainLength = mStationRadius * 6f;            for (int i = 1; i < mCoords.length; i++) {                if (drawInfo.connectionTypes[i - 1] == ConnectionType.TRANSFER)                    mCoords[i] = mCoords[i - 1] + transferLength;                else                    mCoords[i] = mCoords[i - 1] + trainLength;            }        }        @Override        public void draw(Canvas canvas) {            mHeight = getBounds().height();            drawLines(canvas);            drawYellowStations(canvas);            drawTransfers(canvas);            drawStations(canvas);        }        @Override        public void setAlpha(int alpha) {}        @Override        public void setColorFilter(ColorFilter cf) {}        @Override        public int getOpacity() { return PixelFormat.TRANSLUCENT; }        private void drawLines(Canvas canvas) {            mLinePaint.setStrokeWidth(mLineWidth);            float y = mHeight / 2;            float x = mHeight / 2;            for (int i = 0; i < mDrawInfo.connectionTypes.length; i++) {                if (mDrawInfo.connectionTypes[i] == ConnectionType.TRAIN) {                    mLinePaint.setColor(mDrawInfo.stationColors[i]);  // line has the same color as station                    canvas.drawLine(x + mCoords[i], y, x + mCoords[i + 1], y, mLinePaint);                }            }        }        private void drawTransfers(Canvas canvas) {            float y = mHeight / 2;            float x = mHeight / 2;            mFillPaint.setColor(0xff000000);            mLinePaint.setColor(0xff000000);            mLinePaint.setStrokeWidth(mLineWidth + 6);            for (int i = 0; i < mDrawInfo.connectionTypes.length; i++) {   // draw black edging                if (mDrawInfo.connectionTypes[i] == ConnectionType.TRANSFER) {                    canvas.drawCircle(x + mCoords[i], y, mStationRadius + 3, mFillPaint);                    canvas.drawCircle(x + mCoords[i + 1], y, mStationRadius + 3, mFillPaint);                    canvas.drawLine(x + mCoords[i], y, x + mCoords[i + 1], y, mLinePaint);                }            }            mFillPaint.setColor(0xffffffff);            mLinePaint.setColor(0xffffffff);            mLinePaint.setStrokeWidth(mLineWidth + 4);            for (int i = 0; i < mDrawInfo.connectionTypes.length; i++) {   // draw white transfer                if (mDrawInfo.connectionTypes[i] == ConnectionType.TRANSFER) {                    canvas.drawCircle(x + mCoords[i], y, mStationRadius + 2, mFillPaint);                    canvas.drawCircle(x + mCoords[i + 1], y, mStationRadius + 2, mFillPaint);                    canvas.drawLine(x + mCoords[i], y, x + mCoords[i + 1], y, mLinePaint);                }            }        }        private void drawStations(Canvas canvas) {            float y = mHeight / 2;            float x = mHeight / 2;            for (int i = 0; i < mDrawInfo.stationColors.length; i++) {                mFillPaint.setColor(mDrawInfo.stationColors[i]);                canvas.drawCircle(x + mCoords[i], y, mStationRadius, mFillPaint);            }        }        private void drawYellowStations(Canvas canvas) {            mFillPaint.setColor(0xffffff00);            float y = mHeight / 2;            float x = mHeight / 2;            for (int i = 0; i < mDrawInfo.stationColors.length; i++) {                canvas.drawCircle(x + mCoords[i], y, mStationRadius + 1, mFillPaint);            }        }    }}