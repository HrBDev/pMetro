package com.utyf.pmetro.map;import android.util.Log;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.Comparator;/** * Created by Fedor on 17.03.2016. * * Weighted directed graph and shortest paths finding within it. Vertices of the graph are * consecutive integer numbers. */class BaseGraph {    private ArrayList<ArrayList<EdgeInfo>> edges;    private ArrayList<ArrayList<EdgeInfo>> backwardEdges;    private int nVertices;    private int startVertex;    double maxAlternativeLength;    public static class Path {        ArrayList<Integer> vertices;        double length;    }    public interface Callback {        void onShortestPathsComputed(int[] vertices, double[] vertexTimes);    }    private final static double stretchThreshold = 1.6;    // temporal data    private CustomPriorityQueue queue;    private boolean isVisited[]; // Contains value for each vertex, indicating if it has been already extracted from the queue    // output data    private int[] parents;    private int[] backwardParents;    private double[] distances;    private double[] backwardDistances;    class EdgeInfo {        public int toIdx;        public double weight;        public EdgeInfo(int toIdx, double weight) {            this.toIdx = toIdx;            this.weight = weight;        }    }    public BaseGraph() {        edges = new ArrayList<>();        backwardEdges = new ArrayList<>();        nVertices = 0;    }    public void addVertex() {        edges.add(new ArrayList<EdgeInfo>());        backwardEdges.add(new ArrayList<EdgeInfo>());        nVertices++;    }    public void addEdge(int from, int to, double weight) {        edges.get(from).add(new EdgeInfo(to, weight));        backwardEdges.get(to).add(new EdgeInfo(from, weight));    }    // Compute shortest paths using Dijkstra's algorithm    public void computeShortestPaths(int startVertex, int chunkSize, Callback callback) {        int[] vertices = new int[chunkSize];        double[] vertexTimes = new double[chunkSize];        int verticesCount = 0;        this.startVertex = startVertex;        // Reuse allocated memory        if (distances == null || distances.length < nVertices) {            distances = new double[nVertices];            parents = new int[nVertices];            queue = new CustomPriorityQueue();            isVisited = new boolean[nVertices];        }        Arrays.fill(distances, Double.POSITIVE_INFINITY);        Arrays.fill(parents, -1);        distances[startVertex] = 0;        queue.add(startVertex, 0);        Arrays.fill(isVisited, false);        while (!queue.isEmpty()) {            int fromIdx = queue.poll();            // This check increases queue size, but allows not to use "decrease key" operation            if (isVisited[fromIdx])                continue;            isVisited[fromIdx] = true;            vertices[verticesCount] = fromIdx;            vertexTimes[verticesCount] = distances[fromIdx];            verticesCount++;            if (verticesCount == chunkSize) {                callback.onShortestPathsComputed(vertices, vertexTimes);                verticesCount = 0;            }            for (EdgeInfo edgeInfo: edges.get(fromIdx)) {                int toIdx = edgeInfo.toIdx;                double newDistance = distances[fromIdx] + edgeInfo.weight;                if (distances[toIdx] > newDistance) {                    distances[toIdx] = newDistance;                    parents[toIdx] = fromIdx;                    queue.add(toIdx, newDistance);                }            }        }        if (verticesCount > 0) {            int[] verticesPart = Arrays.copyOf(vertices, verticesCount);            double[] vertexTimesPart = Arrays.copyOf(vertexTimes, verticesCount);            callback.onShortestPathsComputed(verticesPart, vertexTimesPart);        }    }    private double computeStretchLowerBound(int v) {        double result = 1d; // Stretch for optimal path        // Move towards end to find a vertex, the shortest path to which from start doesn't go through v        int u = v;        int uPrev;        while (u != -1) {            uPrev = u;            u = backwardParents[u];            while (u != -1) {                if (parents[u] != uPrev)                    break;                uPrev = u;                u = backwardParents[u];            }            // Move towards start to find, where shortest paths from v to end and from u to end join            int y = u == -1 ? uPrev : u;            int w = y;            int z = v;            while (w != -1 && z != -1 && z != w) {                if (distances[w] > distances[z] ||                        distances[w] == distances[z] && parents[w] != -1 &&                                distances[parents[w]] == distances[w])                    w = parents[w];                else                    z = parents[z];            }            if (w == -1 || z == -1)                throw new AssertionError("Start vertex must be reached during this search");            result = Math.max(result, ((backwardDistances[v] - backwardDistances[y]) + (distances[v] - distances[w])) / (distances[y] - distances[w]));        }        return result;    }    private double computeStretch(int viaVertex, int refVertex) {        int startDetour, endDetour;        {            int u = viaVertex;            int v = refVertex;            while (u != -1 && v != -1 && u != v) {                if (distances[u] > distances[v] ||                        distances[u] == distances[v] && parents[u] != -1 &&                        distances[parents[u]] == distances[u])                    u = parents[u];                else                    v = parents[v];            }            if (u == -1 || v == -1)                throw new AssertionError("Start vertex must be reached during this search");            startDetour = u;        }        {            int u = viaVertex;            int v = refVertex;            while (u != -1 && v != -1 && u != v) {                if (backwardDistances[u] > backwardDistances[v] ||                        backwardDistances[u] == backwardDistances[v] && backwardParents[u] != -1 &&                                backwardDistances[backwardParents[u]] == backwardDistances[u]) {                    u = backwardParents[u];                }                else                    v = backwardParents[v];            }            if (u == -1 || v == -1)                throw new AssertionError("Start vertex must be reached during this search");            endDetour = u;        }        return (distances[viaVertex] - distances[startDetour] + backwardDistances[viaVertex] - backwardDistances[endDetour]) /                (distances[refVertex] - distances[startDetour] + backwardDistances[refVertex] - backwardDistances[endDetour]);    }    private ArrayList<Integer> findViaVertices(int endVertex) {        // Reuse allocated memory        if (backwardDistances == null || backwardDistances.length < nVertices) {            backwardDistances = new double[nVertices];            backwardParents = new int[nVertices];            queue = new CustomPriorityQueue();            isVisited = new boolean[nVertices];        }        // Initialize backward Dijkstra search        Arrays.fill(backwardDistances, Double.POSITIVE_INFINITY);        Arrays.fill(backwardParents, -1);        backwardDistances[endVertex] = 0;        queue.add(endVertex, 0);        Arrays.fill(isVisited, false);        // Find candidate via vertices        ArrayList<Integer> viaVertices = new ArrayList<>();        while (!queue.isEmpty()) {            int toIdx = queue.poll();            // This check increases queue size, but allows not to use "decrease key" operation            if (isVisited[toIdx])                continue;            isVisited[toIdx] = true;            // Check if it is a new alternative shortest path            if (toIdx != -1 && backwardParents[toIdx] != -1 && parents[backwardParents[toIdx]] != toIdx) {                double stretchLowerBound = computeStretchLowerBound(toIdx);                if (stretchLowerBound < stretchThreshold)                    viaVertices.add(toIdx);            }            for (EdgeInfo edgeInfo: backwardEdges.get(toIdx)) {                int fromIdx = edgeInfo.toIdx;                double newDistance = backwardDistances[toIdx] + edgeInfo.weight;                // Additionally check if alternative shortest path via fromIdx is less than threshold                // and account for rounding errors                if (backwardDistances[fromIdx] > newDistance &&                        newDistance + distances[fromIdx] < maxAlternativeLength * (1d + 1e-9)) {                    backwardDistances[fromIdx] = newDistance;                    backwardParents[fromIdx] = toIdx;                    queue.add(fromIdx, newDistance);                }            }        }        // Sort via vertices according to lengths of corresponding paths        Collections.sort(viaVertices, new Comparator<Integer>() {            @Override            public int compare(Integer lhs, Integer rhs) {                return Double.compare(distances[lhs] + backwardDistances[lhs], distances[rhs] + backwardDistances[rhs]);            }        });        // Find paths that are not dominated by any shorter path. Their stretch is less then stretchThreshold        int nViaVertices = viaVertices.size();        boolean ok[] = new boolean[nViaVertices];        Arrays.fill(ok, true);        for (int i = 0; i < nViaVertices; i++) {            for (int j = 0; j < i; j++) {                if (!ok[j])                    continue;                double stretch = computeStretch(viaVertices.get(i), viaVertices.get(j));                if (stretch >= stretchThreshold) {                    ok[i] = false;                    break;                }            }        }        // Filter via vertices corresponding to paths that were found        ArrayList<Integer> filteredViaVertices = new ArrayList<>();        for (int i = 0; i < nViaVertices; i++) {            if (ok[i]) {                filteredViaVertices.add(viaVertices.get(i));            }        }        return filteredViaVertices;    }    // Compute length of path from start vertex to end vertex. Shortest paths must be already    // precomputed by calling computeShortestPaths.    public double getPathLength(int v) {        if (distances == null) {            Log.e("getPathLength", "Shortest paths are not computed!");            return Double.POSITIVE_INFINITY;        }        return distances[v];    }    // Get shortest path from start vertex to end. Shortest paths must be already precomputed by    // calling computeShortestPaths.    public Path getPath(int end) {        ArrayList<Integer> verticesList = new ArrayList<>();        int v = end;        while (v != -1) {            verticesList.add(v);            v = parents[v];        }        Collections.reverse(verticesList);        Path path = new Path();        path.vertices = verticesList;        path.length = distances[end];        return path;    }    private Path getBackwardPath(int from) {        ArrayList<Integer> verticesList = new ArrayList<>();        int v = from;        while (v != -1) {            verticesList.add(v);            v = backwardParents[v];        }        Path path = new Path();        path.vertices = verticesList;        path.length = backwardDistances[from];        return path;    }    /*private double calculatePathLength(ArrayList<Integer> path) {        for (int i = 0; i < path.size() - 1; i++) {            int from = path.get(i);            int to = path.get(i + 1);            edges.get(from).indexOf<>()        }    }*/    public ArrayList<Path> getAlternativePaths(int endVertex, double lengthThreshold) {        // Run backward search and traverse shortest path tree so that total path length doesn't        // exceed shortest length plus threshold        maxAlternativeLength = distances[endVertex] + lengthThreshold;        ArrayList<Integer> viaVertices = findViaVertices(endVertex);        // Create alternative shortest paths from via vertices and calculate path lengths        ArrayList<Path> paths = new ArrayList<>();        for (int viaVertex : viaVertices) {            Path path = getPath(viaVertex);            path.vertices.remove(path.vertices.size() - 1); // do not count viaVertex twice            Path backwardPath = getBackwardPath(viaVertex);            path.vertices.addAll(backwardPath.vertices);            path.length += backwardPath.length;            paths.add(path);        }        return paths;    }}